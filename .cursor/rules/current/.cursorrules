# STM32 500双数码管变频器控制系统开发规则
# 项目：500_double_led v1.0
# 芯片：STM32F103C8T6
# 更新：2025-10-25

## 项目基本信息
- 芯片型号：STM32F103C8T6 (64KB Flash, 20KB SRAM)
- 开发工具：Keil MDK-ARM v5.25 + STM32CubeMX
- HAL库版本：STM32Cube_FW_F1_V1.8.x
- 调试接口：SWD (J-Link V9)
- 编译器：ARM Compiler v5.05

## 硬件架构规则

### 必须遵守的硬件约束
1. **调试接口：只使用SWD，禁用JTAG**
   - 原因：避免二次烧录失败
   - 可用：PA13(SWDIO), PA14(SWCLK)
   - 禁用：PB3(JTDO), PB4(NJTRST) 不可作为普通GPIO

2. **74HC595级联配置（3个芯片）**
   - U1: D7数码管段控制(a-dp) + LED阴极
   - U2: D7/D8位选择 + LED阳极（输出经PNP三极管反相，代码需要再次取反）
   - U6: D8数码管段控制(a1-dp1)
   - 数据流向：MOSI → U1 → U2 → U6

3. **74HC165按键输入（9位）**
   - SER + D0-D7 共9个按键输入
   - 与74HC595共享SPI2总线和LATCH引脚
   - 必须先读取按键，再更新显示，避免冲突

4. **SPI2引脚分配（固定，不可更改）**
   - PB13: SCLK (74HC595 SRCLK + 74HC165 SH/CLK)
   - PB14: MISO (74HC165 QH)
   - PB15: MOSI (74HC595 SER)
   - PB7: LATCH (74HC595 RCLK + 74HC165 SH/LD)

5. **数码管类型：共阳极**
   - 段码需要取反（0=亮，1=灭）
   - 位选择高电平有效
   - U2输出需要再次取反（PNP三极管反相）

### LED映射（固定不可更改）
```
LED_ALM  = 0  // D1 报警指示
LED_V    = 1  // D2 电压指示
LED_FR   = 2  // D3 F/R指示（高频模式）
LED_Hz   = 3  // D4 频率单位
LED_RUN  = 4  // D5 运行指示
LED_A    = 5  // D6 电流单位
```

### 按键映射（74HC165, 固定不可更改）
```
KEY_RUN      // SER  运行键
KEY_RESERVED // D0   保留
KEY_ENTER    // D1   确认键
KEY_FUNC     // D2   功能键
KEY_STOP     // D3   停止键
KEY_DOWN     // D4   递减键
KEY_RPG      // D5   编程键
KEY_SHIFT    // D6   位移键
KEY_UP       // D7   递增键
```

## 编码规范

### 显示相关代码规则
1. **数码管段码表：必须对共阳极取反**
   ```c
   // 正确：共阳极数码管段码（已取反）
   const uint8_t seg_code[] = {
       0xC0, 0xF9, 0xA4, 0xB0, 0x99,  // 0-4
       0x92, 0x82, 0xF8, 0x80, 0x90   // 5-9
   };
   ```

2. **U2输出必须再次取反**
   ```c
   // 正确：U2数据在发送前取反（补偿PNP三极管）
   u2_data = ~digit_select_data;
   ```

3. **频率显示格式（严格遵守）**
   - 低频：XXX.XX Hz (小数点在第2位后，精度0.01Hz)
   - 高频：XXXX.X Hz (小数点在第3位后，精度0.1Hz)
   - 高频显示时必须四舍五入

4. **小数点位置代码**
   ```c
   // 低频：小数点在第2位（个位）后
   d7_buffer[2] = seg_code[digit] & ~0x80;
   
   // 高频：小数点在第3位（个位）后
   d7_buffer[3] = seg_code[digit] & ~0x80;
   ```

### 按键处理规则
1. **KEY_Scan()必须使用电平触发模式**
   ```c
   // 错误：边缘触发（长按失效）
   if (key_state != key_last_state) {
       // 消抖
       // 检测按键 ← 只在变化时检测
   }
   return key_pressed;
   
   // 正确：电平触发（支持长按）
   if (key_state != key_last_state) {
       // 消抖（仅在变化时）
   }
   // 检测按键 ← 始终检测当前状态
   return key_pressed;
   ```

2. **长按参数（已优化，不建议修改）**
   - KEY_LONG_PRESS_THRESHOLD = 5 (250ms)
   - KEY_REPEAT_RATE = 2 (100ms)
   - 按键扫描周期 = 50ms

3. **智能步进超时**
   - STEP_TIMEOUT = 500ms
   - 超时后必须重置为STEP_LEVEL_1

### 时序控制规则
1. **刷新周期（已优化）**
   - 显示刷新：20ms (50Hz)
   - 按键扫描：50ms (20Hz)
   - 必须使用HAL_GetTick()做定时，不使用HAL_Delay()阻塞

2. **SPI通信顺序**
   ```c
   // 正确顺序：先读取按键，再更新显示
   1. KEY_Scan() - 读取74HC165
   2. 处理按键逻辑
   3. SPI_Display_Refresh() - 更新74HC595
   ```

## 已知错误及解决方案（必须遵守）

### 错误1：二次烧录失败
**症状：** Flash Download failed, JTAG chain error
**原因：** 使用了JTAG相关GPIO或Flash算法错误
**解决方案：**
- Keil配置：Debug选项选择SWD（不选JTAG）
- Flash算法：STM32F10x Med-density 64KB
- 避免使用PB3/PB4作为普通GPIO
- 禁用所有JTAG相关配置

### 错误2：长按功能无效
**症状：** 长按UP/DOWN键无连续触发
**原因：** KEY_Scan()使用边缘触发，长按期间返回KEY_NONE
**解决方案：**
- 将按键检测逻辑移到状态变化判断之外
- 始终返回当前按键状态，不仅在状态变化时

### 错误3：高频小数点位置错误
**症状：** 0.1Hz显示为00.001
**原因：** 小数点放在百位后（第1位），应在个位后（第3位）
**解决方案：**
```c
// 错误
d7_buffer[1] = seg_code[digit] & ~0x80;  // 百位带小数点

// 正确
d7_buffer[3] = seg_code[digit] & ~0x80;  // 个位带小数点
```

### 错误4：D8小数点位置错误
**症状：** 245.13显示为2451.3
**原因：** 小数点位置参数错误
**解决方案：**
```c
// 电流显示格式：XXX.XX A
SEG_SetDigit_D8(2, digit, 1);  // 第2位（个位）带小数点
```

### 错误5：按键映射混乱
**症状：** STOP键执行DOWN功能
**原因：** 74HC165的9位输入映射错误
**解决方案：**
- 必须严格按照硬件连接定义映射
- SER(bit0) → RUN, D0(bit1) → RESERVED, ..., D7(bit8) → UP

### 错误6：智能步进每次按键就升级
**症状：** 每按一次步进就升级到下一级别
**原因：** 升级逻辑在每次按键时都执行
**解决方案：**
- UP键：频率超过阈值时才升级
- DOWN键：频率为步进倍数时才升级
- 超时后重置为级别1

### 错误7：编译错误 case label重复
**症状：** case label value has already appeared
**原因：** switch-case中有重复的case值
**解决方案：**
- 检查KEY_SHIFT和KEY_RPG等枚举值是否重复
- 确保74HC165的9位映射唯一

### 错误8：key_long_press_count未定义
**症状：** identifier "key_long_press_count" is undefined
**原因：** 变量声明被意外删除
**解决方案：**
- 在main.c的Private variables区域添加：
  ```c
  uint8_t key_long_press_count = 0;
  ```

### 错误9：SPI_HandleTypeDef未定义
**症状：** identifier "SPI_HandleTypeDef" is undefined
**原因：** 缺少SPI头文件包含
**解决方案：**
- 在stm32f1xx_hal_msp.c和main.c中包含：
  ```c
  #include "stm32f1xx_hal_spi.h"
  ```

### 错误10：DOWN键步进逻辑错误
**症状：** DOWN键步进不正确
**原因：** 步进降级逻辑错误或自动判定步进级别
**解决方案：**
- 移除AutoSetStepLevel()函数
- DOWN键超时后也重置为级别1
- 按频率倍数判断升级（如0.10, 1.00, 10.00）

### 错误11：长按重复触发时机不正确
**症状：** 长按UP/DOWN键时，达到阈值后第一次重复触发有延迟
**原因：** 重复触发的计算逻辑有off-by-one错误
**解决方案：**
```c
// 错误：达到阈值(count=5)时，5 % 2 = 1，不会立即触发
if (key_long_press_count % KEY_REPEAT_RATE == 0) {
    should_execute = 1;
}

// 正确：从达到阈值开始计算重复间隔
if ((key_long_press_count - KEY_LONG_PRESS_THRESHOLD) % KEY_REPEAT_RATE == 0) {
    should_execute = 1;
}
```
**说明：**
- KEY_LONG_PRESS_THRESHOLD = 5 (250ms，5次扫描周期)
- KEY_REPEAT_RATE = 2 (100ms，2次扫描周期)
- 修复后：达到阈值(count=5)时立即触发第一次重复，然后每100ms重复一次
- 时间线：0ms首次触发 → 250ms第一次重复 → 350ms第二次重复 → 450ms第三次重复...

### 错误12：中文文件名乱码问题
**症状：** 使用PowerShell创建中文文件夹时出现乱码（如：宸ョ▼鏂囦欢、浣跨敤璇存槑）
**原因：** PowerShell默认使用GBK编码，而中文UTF-8编码在GBK下显示为乱码
**解决方案：**
**唯一有效方案：使用UTF-8编码创建中文文件夹**
```batch
@echo off
chcp 65001  # 必须设置UTF-8编码
echo 创建中文文件夹...
mkdir "工程文件"
mkdir "配置指南"
mkdir "问题修复"
mkdir "备份版本"
mkdir "使用说明"
mkdir "版本更新记录"
```

**说明：**
- 问题根源：PowerShell编码问题
- 唯一有效预防：使用`chcp 65001`设置UTF-8编码
- 验证：检查文件夹名称是否正确显示
- 注意：重命名和删除乱码文件夹的方案在实际操作中失败，不推荐使用

### 错误13：文件整合操作规范
**症状：** 在文件整理过程中出现乱码文件夹，导致文件重复或丢失
**原因：** 文件移动操作时未正确处理中文编码，导致文件夹名称乱码
**解决方案：**
1. **文件整合标准流程：**
   ```batch
   @echo off
   chcp 65001
   echo 执行文件整合操作...
   
   # 检查乱码文件夹
   if exist "澶囦唤鐗堟湰" (
       echo 发现乱码文件夹，开始整合...
       
       # 复制完整项目文件
       if exist "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\500 double led.ioc" (
           copy "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\500 double led.ioc" "备份版本\v1.0_完整备份\"
       )
       
       # 复制Core文件夹
       if exist "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\Core" (
           xcopy "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\Core" "备份版本\v1.0_完整备份\Core" /E /I /Y
       )
       
       # 复制Drivers文件夹
       if exist "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\Drivers" (
           xcopy "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\Drivers" "备份版本\v1.0_完整备份\Drivers" /E /I /Y
       )
       
       # 复制MDK-ARM文件夹
       if exist "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\MDK-ARM" (
           xcopy "澶囦唤鐗堟湰\v1.0_瀹屾暣澶囦唤\MDK-ARM" "备份版本\v1.0_完整备份\MDK-ARM" /E /I /Y
       )
       
       # 删除乱码文件夹
       rd /s /q "澶囦唤鐗堟湰"
       echo 文件整合完成！
   )
   ```

2. **文件整合检查清单：**
   - [ ] 使用UTF-8编码（chcp 65001）
   - [ ] 检查源文件夹是否存在
   - [ ] 验证目标文件夹路径正确
   - [ ] 确认文件复制完整性
   - [ ] 删除乱码文件夹
   - [ ] 更新README文档

3. **常见乱码文件夹映射：**
   ```
   澶囦唤鐗堟湰     → 备份版本
   v1.0_瀹屾暣澶囦唤 → v1.0_完整备份
   宸ョ▼鏂囦欢      → 工程文件
   浣跨敤璇存槑     → 使用说明
   鐗堟湰鏇存柊璁板綍 → 版本更新记录
   閰嶇疆鎸囧崡     → 配置指南
   ```

**说明：**
- 问题根源：文件操作时编码处理不当
- 预防：始终使用UTF-8编码进行文件操作
- 修复：按标准流程整合文件，删除乱码文件夹
- 验证：检查文件完整性，确认无乱码文件夹存在

## 智能步进规则（核心算法，不可随意修改）

### 低频模式 (0.00-400.00Hz)
```
级别1: 0.00 ~ 0.09Hz  → 步进 0.01Hz  (freq <= 9)
级别2: 0.10 ~ 0.90Hz  → 步进 0.1Hz   (freq <= 90)
级别3: 1.00 ~ 9.90Hz  → 步进 1Hz     (freq <= 990)
级别4: 10.00 ~ 400.00Hz → 步进 10Hz  (freq <= 40000)
```

### 高频模式 (0.0-4000.0Hz)
```
级别1: 0.0 ~ 0.9Hz    → 步进 0.1Hz   (freq <= 90)
级别2: 1.0 ~ 9.9Hz    → 步进 1Hz     (freq <= 990)
级别3: 10.0 ~ 99.9Hz  → 步进 10Hz    (freq <= 9990)
级别4: 100.0 ~ 4000.0Hz → 步进 100Hz (freq <= 400000)
```

### 升级规则
- UP键：CheckStepLevelUpgrade() - 频率超过当前级别上限时升级
- DOWN键：CheckStepLevelUpgradeForDown() - 频率为步进倍数时升级
- 超时：500ms无操作后重置为级别1

## 代码审查检查清单

### 修改代码前必须检查
- [ ] 是否使用了JTAG相关GPIO？
- [ ] 数码管段码是否取反？
- [ ] U2输出是否再次取反？
- [ ] 小数点位置是否正确？
- [ ] 按键映射是否正确？
- [ ] KEY_Scan()是否电平触发？
- [ ] 是否使用HAL_Delay()阻塞主循环？
- [ ] 智能步进逻辑是否正确？

### 编译前必须检查
- [ ] 无未定义的标识符
- [ ] 无重复的case标签
- [ ] 所有必要的头文件已包含
- [ ] Flash算法配置正确（64KB）

### 烧录前必须检查
- [ ] Debug接口选择SWD
- [ ] J-Link设备识别正常
- [ ] 目标芯片选择STM32F103C8

## 新功能开发指导

### 添加新按键功能
1. 在key.h中定义新的KEY_XXX枚举
2. 在key.c的KEY_Scan()中添加映射
3. 在main.c的switch-case中添加处理逻辑
4. 确定是否需要长按支持（修改should_execute逻辑）

### 添加新的显示内容
1. 在segment_display.h中声明函数
2. 在segment_display.c中实现显示逻辑
3. 注意小数点位置和格式
4. 更新d7_buffer或d8_buffer
5. 调用UpdateDisplay()刷新

### 添加菜单功能
1. 在menu_system.h中定义菜单结构
2. 在menu_system.c中实现菜单逻辑
3. 在main.c中调用MENU_ProcessKey()
4. 根据菜单状态切换显示内容

## 性能优化建议
- 避免在主循环中使用HAL_Delay()
- 使用定时器做周期性任务
- SPI通信尽量批量发送
- 减少不必要的全局变量

## 调试技巧
1. 使用Keil调试器查看变量值
2. 用示波器检查SPI波形
3. 单独测试显示和按键功能
4. 逐步调试智能步进逻辑
5. 检查定时器周期是否准确

## 禁止操作
❌ 修改74HC595/74HC165的引脚定义
❌ 修改LED和按键映射
❌ 使用JTAG调试接口
❌ 在主循环中使用长延迟
❌ 修改已验证的段码表
❌ 随意修改智能步进阈值
❌ 删除PNP三极管反相补偿
❌ 修改显示格式规范

## 版本管理
- 每次重大修改后创建历史版本
- 版本命名：500_double_led_vX.Y
- 必须包含：源代码 + 版本说明 + README
- 记录所有bug修复到.cursorrules

## 文件组织规则（避免中文乱码）

### 文件夹命名规范
1. **中文文件夹创建：**
   ```batch
   @echo off
   chcp 65001  # 必须设置UTF-8编码
   mkdir "工程文件"
   mkdir "配置指南"
   mkdir "问题修复"
   mkdir "备份版本"
   mkdir "使用说明"
   mkdir "版本更新记录"
   ```

2. **文件移动操作：**
   ```batch
   @echo off
   chcp 65001  # 必须设置UTF-8编码
   Move-Item "源文件" "目标文件夹"
   ```

3. **乱码文件夹处理：**
   - 识别乱码：`宸ョ▼鏂囦欢`、`浣跨敤璇存槑`、`澶囦唤鐗堟湰`等
   - 重命名修复：使用正确的中文名称
   - 删除乱码：如果内容已合并，删除乱码文件夹

### 项目文件结构
```
software/
├── 工程文件/          ← 主要工程文件
├── 配置指南/          ← 配置指南文档
├── 问题修复/          ← 问题修复文档
├── 备份版本/          ← 备份版本文件
├── 使用说明/          ← 使用说明文档
├── 版本更新记录/      ← 版本更新记录
└── README.md          ← 软件文件夹说明
```

### 文件组织检查清单
- [ ] 所有中文文件夹名称正确显示
- [ ] 无乱码文件夹存在
- [ ] 文件夹内容完整
- [ ] 文件路径无特殊字符
- [ ] 使用UTF-8编码创建文件夹

## 项目交接清单
新开发者接手时必须：
1. 阅读README.txt了解项目概况
2. 阅读版本说明_vX.Y.txt了解功能
3. 阅读本.cursorrules文件了解规则
4. 检查硬件连接是否与代码一致
5. 使用SWD接口测试烧录
6. 运行基础功能测试

## 联系与支持
- 开发工具：Cursor AI + STM32CubeMX
- HAL库文档：查阅STM32CubeF1官方文档
- 硬件手册：74HC595/74HC165数据手册
- 调试工具：J-Link V9 + SWD

### 错误14：PowerShell中文文件名乱码问题
**症状：** 使用PowerShell重命名或创建中文文件名时出现乱码（如：AI鍗忎綔鎸囧崡.md）
**原因：** PowerShell默认编码设置导致中文字符被错误编码，即使设置了chcp 65001也可能在某些操作中失效
**解决方案：**

#### 1. 立即修复方案
```powershell
# 设置UTF-8编码
chcp 65001

# 设置控制台输出编码
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 修复乱码文件名
Rename-Item "乱码文件名" "正确中文名" -ErrorAction SilentlyContinue
```

#### 2. 预防措施
**使用安全的中文文件名操作函数：**
```powershell
# 重命名文件
Set-ChineseFileName -OldName "旧文件名" -NewName "新文件名" -Path "路径"

# 创建中文文件
New-ChineseFile -FileName "文件名.md" -Content "内容" -Path "路径"

# 创建中文文件夹
New-ChineseDirectory -DirectoryName "文件夹名" -Path "路径"
```

#### 3. 标准操作流程
1. **始终先设置编码**：`chcp 65001`
2. **设置控制台编码**：`[Console]::OutputEncoding = [System.Text.Encoding]::UTF8`
3. **使用安全函数**：避免直接使用Rename-Item或New-Item
4. **验证结果**：操作后检查文件名是否正确显示

#### 4. 常见乱码映射
```
AI鍗忎綔鎸囧崡.md     → AI协作指南.md
娴嬭瘯楠岃瘉鏂囨。.md  → 测试验证文档.md
椤圭洰鎬荤粨.md       → 项目总结.md
楠屾敹娓呭崟.md       → 验收清单.md
淇鎬荤粨.txt         → 修复总结.txt
鍗忎綔鎸囧崡.md       → 协作指南.md
鍙樻洿鏃ュ織.md       → 变更日志.md
鏁呴殰鎺掗櫎鎸囧崡.md  → 故障排除指南.md
鏂囨。绱㈠紩.md       → 文档索引.md
鏈€缁堟€荤粨.md       → 最终总结.md
```

#### 5. 最终成功方案（推荐）
**使用批处理脚本修复乱码文件名：**
```batch
@echo off
chcp 65001
echo 最终修复所有乱码文件名...

cd "D:\stm32\BilibiliProject\500 double led"

echo 当前目录内容：
dir /b *.md *.txt

echo.
echo 开始修复乱码文件名...

REM 修复所有乱码文件名
if exist "AI鍗忎綔鎸囧崡.md" (
    ren "AI鍗忎綔鎸囧崡.md" "AI协作指南.md"
    echo 已修复：AI鍗忎綔鎸囧崡.md -> AI协作指南.md
)

if exist "娴嬭瘯楠岃瘉鏂囨。.md" (
    ren "娴嬭瘯楠岃瘉鏂囨。.md" "测试验证文档.md"
    echo 已修复：娴嬭瘯楠岃瘉鏂囨。.md -> 测试验证文档.md
)

if exist "椤圭洰鎬荤粨.md" (
    ren "椤圭洰鎬荤粨.md" "项目总结.md"
    echo 已修复：椤圭洰鎬荤粨.md -> 项目总结.md
)

if exist "楠屾敹娓呭崟.md" (
    ren "楠屾敹娓呭崟.md" "验收清单.md"
    echo 已修复：楠屾敹娓呭崟.md -> 验收清单.md
)

if exist "淇鎬荤粨.txt" (
    ren "淇鎬荤粨.txt" "修复总结.txt"
    echo 已修复：淇鎬荤粨.txt -> 修复总结.txt
)

if exist "鍗忎綔鎸囧崡.md" (
    ren "鍗忎綔鎸囧崡.md" "协作指南.md"
    echo 已修复：鍗忎綔鎸囧崡.md -> 协作指南.md
)

if exist "鍙樻洿鏃ュ織.md" (
    ren "鍙樻洿鏃ュ織.md" "变更日志.md"
    echo 已修复：鍙樻洿鏃ュ織.md -> 变更日志.md
)

if exist "鏁呴殰鎺掗櫎鎸囧崡.md" (
    ren "鏁呴殰鎺掗櫎鎸囧崡.md" "故障排除指南.md"
    echo 已修复：鏁呴殰鎺掗櫎鎸囧崡.md -> 故障排除指南.md
)

if exist "鏂囨。绱㈠紩.md" (
    ren "鏂囨。绱㈠紩.md" "文档索引.md"
    echo 已修复：鏂囨。绱㈠紩.md -> 文档索引.md
)

if exist "鏈€缁堟€荤粨.md" (
    ren "鏈€缁堟€荤粨.md" "最终总结.md"
    echo 已修复：鏈€缁堟€荤粨.md -> 最终总结.md
)

echo.
echo 修复完成！当前目录内容：
dir /b *.md *.txt

echo.
echo 乱码文件名修复完成！
pause
```

**最终成功方案特点：**
- **使用批处理脚本**：避免PowerShell编码问题
- **UTF-8编码设置**：`chcp 65001` 确保正确编码
- **精确文件名映射**：使用正确的乱码文件名
- **错误处理**：`if exist` 检查文件存在性
- **结果验证**：修复后显示文件列表确认

**说明：**
- **问题根源**：PowerShell编码设置不完整
- **预防**：使用安全函数，始终设置完整编码
- **修复**：按标准流程重新设置编码并重命名
- **验证**：操作后检查文件名显示是否正确

### 错误15：Git提交信息中文乱码问题
**症状：** Git log显示中文乱码（如：娣诲姞GitHub鎺ㄩ€佸伐鍏峰拰璁よ瘉璇存槑鏂囨。）
**原因：** PowerShell默认使用GBK编码，Git commit时中文被错误编码
**解决方案：**

#### 1. 永久配置Git编码（必须执行）
```powershell
# 配置Git使用UTF-8编码
git config --global core.quotepath false        # 不转义非ASCII字符
git config --global i18n.commitencoding utf-8   # commit信息使用UTF-8
git config --global i18n.logoutputencoding utf-8 # log输出使用UTF-8
git config --global gui.encoding utf-8           # GUI界面使用UTF-8
```

#### 2. 配置PowerShell编码（每次会话必须执行）
```powershell
# 设置PowerShell编码为UTF-8
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::InputEncoding = [System.Text.Encoding]::UTF8
```

#### 3. 永久配置PowerShell（推荐）
**编辑PowerShell配置文件：**
```powershell
# 检查配置文件位置
echo $PROFILE

# 创建配置文件（如果不存在）
New-Item -Path $PROFILE -Type File -Force

# 编辑配置文件，添加以下内容：
notepad $PROFILE
```

**在配置文件中添加：**
```powershell
# 设置PowerShell编码为UTF-8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::InputEncoding = [System.Text.Encoding]::UTF8
$OutputEncoding = [System.Text.Encoding]::UTF8
chcp 65001 > $null
```

#### 4. 使用自动配置脚本
**运行项目中的编码修复脚本：**
```powershell
.\fix_encoding.ps1
```

#### 5. 已存在的乱码commit处理
**注意：** 已提交的乱码commit信息无法简单修复
- ✅ **推荐做法**：保持不变，GitHub网页端通常能正确显示
- ❌ **不推荐**：修改Git历史（需要force push，会影响协作）

**验证在GitHub网页端：**
访问仓库的commits页面，GitHub通常能自动检测编码并正确显示中文。

#### 6. 标准Git操作流程
```powershell
# 1. 确保编码配置正确（第一次）
git config --global core.quotepath false
git config --global i18n.commitencoding utf-8
git config --global i18n.logoutputencoding utf-8
git config --global gui.encoding utf-8

# 2. 每次打开PowerShell后设置编码（或配置到$PROFILE）
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# 3. 正常使用Git
git add .
git commit -m "添加新功能"  # 中文将正确编码
git push
```

#### 7. 验证配置
```powershell
# 检查Git配置
git config --global -l | Select-String "i18n|core.quotepath|gui.encoding"

# 检查PowerShell编码
[Console]::OutputEncoding
$OutputEncoding

# 测试中文显示
echo "测试中文"
git log --oneline -1
```

#### 8. 常见问题
**Q: 为什么配置后还是乱码？**
A: 需要同时配置Git和PowerShell编码，缺一不可

**Q: 已有的乱码commit能修复吗？**
A: 不建议修改，GitHub网页端通常能正确显示

**Q: 每次都要设置PowerShell编码吗？**
A: 配置到$PROFILE后，每次启动PowerShell自动加载

**说明：**
- **问题根源**：PowerShell GBK编码 + Git未配置UTF-8
- **彻底解决**：Git全局配置UTF-8 + PowerShell配置文件
- **预防**：使用`fix_encoding.ps1`脚本一键配置
- **验证**：检查配置项 + 测试中文commit
- **最佳实践**：优先使用GitHub Desktop（自动处理编码）

---
最后更新：2025-10-28
版本：v1.0.1
状态：已验证，可用于生产

